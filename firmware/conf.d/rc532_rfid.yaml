binary_sensor:
  - platform: template
    name: "NFC Tag Present"
    id: nfc_tag_present
    state_topic:
    icon: mdi:circle-double
    web_server:
      sorting_group_id: sorting_group_rfid

spi:
  clk_pin: GPIO39 # SCK
  miso_pin: GPIO37 # MO/SDA/TX
  mosi_pin: GPIO35 # M

pn532_spi:
  cs_pin: GPIO33 # NSS/SCL/RX
  id: nfc_reader
  on_tag_removed:
    then:
      - light.turn_on: #TODO: change to script.execute: set_led_blue
          id: neopixel_light
          brightness: 0%
          red: 0%
          green: 0%
          blue: 0%
          effect: none
      - binary_sensor.template.publish:
          id: nfc_tag_present
          state: OFF
      - lambda: |-
          id(filament_raw_data).publish_state("");
  on_tag:
    then:
      - binary_sensor.template.publish:
          id: nfc_tag_present
          state: ON
      - lambda: |-
          bool tag_read_success = false;
          auto tag_type = tag.get_tag_type();
          ESP_LOGD("NFC", "Tag type: %s", tag_type.c_str());

          if (tag.has_ndef_message()) {
            ESP_LOGD("NFC", "NDEF message found");
            auto message = tag.get_ndef_message();
            auto records = message->get_records();
            bool json_record_found = false;

            for (auto &record : records) {
              if (record->get_type() == "application/json") {
                if (json_record_found) {
                  ESP_LOGE("NFC", "Multiple JSON NDEF records found, not a valid OpenSpool tag");
                  break;
                }
                json_record_found = true;

                auto data = record->get_payload();
                ESP_LOGD("NFC", "JSON record found: %s", data.c_str());
                id(filament_raw_data).publish_state(data.c_str());

                bool parse_result = esphome::json::parse_json(data, [&](const JsonObject& root) -> bool {
                  if (root.containsKey("protocol") && root["protocol"] == "openspool") {
                    ESP_LOGD("NFC", "Tag is an openspool tag");
                    if (!root.containsKey("version")) {
                      ESP_LOGE("NFC", "Missing version field");
                      return false;
                    }
                    if (root["version"] == "1.0") {
                      ESP_LOGD("NFC", "OpenSpool - v1.0");
                      if (!root.containsKey("color_hex")) {
                        ESP_LOGE("NFC", "Missing color_hex field, required for OpenSpool v1.0");
                        return false;
                      }
                      if (!root.containsKey("brand")) {
                        ESP_LOGE("NFC", "Missing brand field, required for OpenSpool v1.0");
                        return false;
                      }
                      if (!root.containsKey("type")) {
                        ESP_LOGE("NFC", "Missing type field, required for OpenSpool v1.0");
                        return false;
                      }
                      if (!root.containsKey("min_temp")) {
                        ESP_LOGE("NFC", "Missing min_temp field, required for OpenSpool v1.0");
                        return false;
                      }
                      if (!root.containsKey("max_temp")) {
                        ESP_LOGE("NFC", "Missing max_temp field, required for OpenSpool v1.0");
                        return false;
                      }
                      
                      // If we've made it this far, all required fields are present
                      tag_read_success = true;
                      
                      // Publish the data
                      id(filament_color_hex).publish_state(root["color_hex"]);
                      id(filament_brand).publish_state(root["brand"]);
                      id(filament_type).publish_state(root["type"]);
                      id(filament_min_temp).publish_state(root["min_temp"]);
                      id(filament_max_temp).publish_state(root["max_temp"]);
                    } else {
                      ESP_LOGE("NFC", "Unsupported version: %s", root["version"].as<std::string>().c_str());
                      return false;
                    }
                  } else {
                    ESP_LOGE("NFC", "Tag is not an openspool tag");
                    return false;
                  }
                  return true;
                });
                
                if (!parse_result) {
                  ESP_LOGE("NFC", "Failed to parse JSON data");
                }
              }
            }
            if (!json_record_found) {
              ESP_LOGE("NFC", "No JSON record found, not an openspool tag");
            }
          }
          
          auto call = id(neopixel_light).make_call(); //TODO: refactor to reuse script.execute: set_led_green
          // Only execute the script if the tag was read successfully
          if (tag_read_success) {
            call.set_rgb(0.0, 1.0, 0.0); // green
            id(publish_filament_setting).execute();
          } else {
            call.set_rgb(1.0, 0.0, 0.0); // red
            ESP_LOGE("NFC", "Tag read failed, not publishing settings");
          }
          call.set_brightness(1.0); // 100%
          call.perform();

text_sensor:
  - platform: template
    name: "NFC Raw Data"
    id: filament_raw_data
    state_topic:
    icon: mdi:nfc-variant
    web_server:
      sorting_group_id: sorting_group_rfid
    filters:
      - lambda: |-
          auto pretty_json = [](const std::string &x) -> std::string {
            if (x.empty()) {
              ESP_LOGD("NFC", "Input string is empty");
              return x;
            }     
            ESP_LOGD("NFC", "Input string: %s", x.c_str());
            
            DynamicJsonDocument doc(1024);  // Adjust size as needed
            DeserializationError error = deserializeJson(doc, x);
            if (error) {
              ESP_LOGE("NFC", "JSON parsing failed: %s", error.c_str());
              return "JSON parsing failed: " + std::string(error.c_str());
            }
            
            std::string output;
            serializeJsonPretty(doc, output);
            return output;
          };
          return pretty_json(x);

  - platform: template
    name: "NFC Preview"
    id: nfc_preview
    state_topic:
    icon: mdi:nfc-search-variant
    web_server:
      sorting_group_id: sorting_group_rfid

# Create virtual button that can be pressed in the gui
button:
  - platform: template
    name: "Write NFC"
    icon: mdi:nfc-tap
    state_topic:
    web_server:
      sorting_group_id: sorting_group_rfid
    on_press:
      then:
        - if:
            condition:
              and:
                - lambda: |-
                    if (!id(nfc_tag_present).state) {
                      ESP_LOGE("main", "NFC Tag not present");
                      return false;
                    } else {
                      return true;
                    }
                - lambda: |-
                    if (id(filament_brand).state == "") {
                      ESP_LOGE("main", "Filament Brand cannot be empty");
                      return false;
                    } else {
                      return true;
                    }
                - lambda: |-
                    if (id(filament_brand_code).state == "") {
                      ESP_LOGE("main", "Filament Brand Code cannot be empty");
                      return false;
                    } else {
                      return true;
                    }
                - lambda: |-
                    if (id(filament_color_hex).state == "") {
                      ESP_LOGE("main", "Filament Color Hex cannot be empty");
                      return false;
                    } else {
                      return true;
                    }
                - lambda: |-
                    if (id(filament_max_temp).state >= 300) {
                      ESP_LOGE("main", "Filament Min Temp must be less than 300");
                      return false;
                    } else {
                      return true;
                    }
                - lambda: |-
                    if (id(filament_min_temp).state <= 150) {
                      ESP_LOGE("main", "Filament Max Temp must be greater than 150");
                      return false;
                    } else {
                      return true;
                    }
                - lambda: |-
                    if (id(filament_type).state == "") {
                      ESP_LOGE("main", "Filament Type cannot be empty");
                      return false;
                    } else {
                      return true;
                    }
            then:
              - lambda: |-
                  auto message = new nfc::NdefMessage();
                  auto record = std::make_unique<nfc::NdefRecord>();
                  record->set_tnf(nfc::TNF_WELL_KNOWN);
                  record->set_type("application/json");

                  DynamicJsonDocument doc(256);  // Adjust size as needed
                  JsonObject root = doc.to<JsonObject>();
                  root["version"] = "1.0";
                  root["protocol"] = "openspool";
                  root["color_hex"] = id(filament_color_hex).state;
                  root["type"] = id(filament_type).state;
                  root["min_temp"] = id(filament_min_temp).state;
                  root["max_temp"] = id(filament_max_temp).state;
                  root["brand"] = id(filament_brand).state;

                  std::string json_string;
                  serializeJson(root, json_string);

                  ESP_LOGI("rfid", "JSON content to be written: %s", json_string.c_str());

                  record->set_payload(json_string);

                  message->add_record(std::move(record));

                  id(nfc_reader).write_mode(message);
                  ESP_LOGI("rfid", "Writing JSON NDEF message to tag");
                  //TODO: do I need to set back to read mode?
            else:
              - lambda: |-
                  ESP_LOGI("rfid", "NFC Tag not present");

# logger:
#   level: VERBOSE
#   logs:
#     pn532: VERBOSE
#     nfc: VERBOSE
#     mqtt: INFO
#     wifi: INFO
