script:
  - id: clear_filament_settings #TODO: unused
    then:
      - select.set:
          id: filament_brand
          option: "Generic"
      - text_sensor.template.publish:
          id: filament_brand_code
          state: ""
      - select.set:
          id: filament_color
          option: ""
      - text_sensor.template.publish:
          id: filament_color_hex
          state: ""
      - text_sensor.template.publish:
          id: filament_color_hex_bambu
          state: ""
      - number.set:
          id: filament_min_temp
          value: 150
      - number.set:
          id: filament_max_temp
          value: 300
      - select.set:
          id: filament_type
          option: "PLA"
  - id: preview_rfid_data
    then:
      - text_sensor.template.publish:
          id: nfc_preview
          state: !lambda |-
            auto pretty_json = [=]() -> std::string {
              //TODO: DynamicJsonDocument is memory inefficient, use StaticJsonDocument instead
              DynamicJsonDocument doc(256);  // Adjust size as needed
              JsonObject root = doc.to<JsonObject>();
              
              root["protocol"] = "openspool";
              root["version"] = "1.0";
              root["brand"] = id(filament_brand).state.c_str();
              root["color_hex"] = id(filament_color_hex).state.c_str();
              root["min_temp"] = id(filament_min_temp).state;
              root["max_temp"] = id(filament_max_temp).state;
              root["type"] = id(filament_type).state.c_str();
              root["brand"] = id(filament_brand).state.c_str();

              std::string output;
              serializeJsonPretty(doc, output);
              return output;
            };
            return pretty_json();
  - id: publish_filament_setting #TODO: unused
    then:
      - if:
          condition:
            and:
              - lambda: |-
                  if (id(filament_brand).state == "" || id(filament_brand).state == "Unknown") {
                    ESP_LOGE("main", "Filament Brand cannot be empty");
                    return false;
                  } else {
                    return true;
                  }
              - lambda: |-
                  if (id(filament_brand_code).state == "" || id(filament_brand_code).state == "Unknown") {
                    ESP_LOGE("main", "Filament Brand Code cannot be empty");
                    return false;
                  } else {
                    return true;
                  }
              - lambda: |-
                  if (id(filament_color_hex).state == "") {
                    ESP_LOGE("main", "Filament Color Hex cannot be empty");
                    return false;
                  } else {
                    return true;
                  }
              - lambda: |-
                  if (id(filament_max_temp).state >= 300) {
                    ESP_LOGE("main", "Filament Min Temp must be less than 300");
                    return false;
                  } else {
                    return true;
                  }
              - lambda: |-
                  if (id(filament_min_temp).state <= 150) {
                    ESP_LOGE("main", "Filament Max Temp must be greater than 150");
                    return false;
                  } else {
                    return true;
                  }
              - lambda: |-
                  if (id(filament_type).state == "") {
                    ESP_LOGE("main", "Filament Type cannot be empty");
                    return false;
                  } else {
                    return true;
                  }
              - lambda: |-
                  if (id(filament_type).state == "") {
                    ESP_LOGE("main", "Filament Type cannot be empty");
                    return false;
                  } else {
                    return true;
                  }
              - lambda: |-
                  if (id(bambu_serial_number).state == "") {
                    ESP_LOGE("main", "Bambu Serial Number cannot be empty");
                    return false;
                  } else {
                    return true;
                  }
              # TODO: Check if mqtt is enabled once this is merged: https://github.com/esphome/esphome/pull/7716
          then:
            - mqtt.publish:
                # topic: device/${bambu_serial_number}/request
                topic: !lambda 'return "device/" + id(bambu_serial_number).state + "/request";'
                payload: !lambda |-
                  auto data = json::build_json([=](JsonObject root) {
                    auto print = root.createNestedObject("print");
                    print["sequence_id"] = "0";
                    print["command"] = "ams_filament_setting";
                    print["ams_id"] = 255; //TODO: support multiple AMS
                    print["tray_id"] = 254; //TODO: support multiple trays
                    print["tray_color"] = id(filament_color_hex_bambu).state.c_str();
                    print["nozzle_temp_min"] = id(filament_min_temp).state; //TODO: string or int? 
                    print["nozzle_temp_max"] = id(filament_max_temp).state; //TODO: string or int? 
                    print["tray_type"] = id(filament_type).state.c_str();
                    print["setting_id"] = "";
                    print["tray_info_idx"] = id(filament_brand_code).state.c_str();
                    print["tray_type"] = id(filament_type).state.c_str();
                    //print["tray_sub_brands"] = "TPU"; //TODO: support sub brands

                  });
                  ESP_LOGI("main", "Publishing %s", data.c_str());
                  return data;
  - id: generate_filament_brand_code
    then:
      - lambda: |-
          id(filament_sub_brand).publish_state("");
          // TPU
          if (id(filament_type).state == "TPU") {
            if (id(filament_brand).state == "Bambu") {
              id(filament_brand_code).publish_state("GFU01");
              id(filament_sub_brand).publish_state("TPU 95A");
            } else { // Generic
              id(filament_brand_code).publish_state("GFU99");
              id(filament_sub_brand).publish_state("TPU");
            }
          }
          // PLA
          else if (id(filament_type).state == "PLA") {
            if (id(filament_brand).state == "PolyTerra") {
              id(filament_brand_code).publish_state("GFL01");
              id(filament_sub_brand).publish_state("PolyTerra PLA");
            } else if (id(filament_brand).state == "PolyLite") {
              id(filament_brand_code).publish_state("GFL00");
              id(filament_sub_brand).publish_state("PolyLite PLA");
            } else if (id(filament_brand).state == "Bambu") {
              // Check for Bambu PLA variants
              if (id(filament_variant).state == "Basic") {
                id(filament_brand_code).publish_state("GFA00");
                id(filament_sub_brand).publish_state("PLA Basic");
              } else if (id(filament_variant).state == "Matte") {
                id(filament_brand_code).publish_state("GFA01");
                id(filament_sub_brand).publish_state("PLA Matte");
              } else if (id(filament_variant).state == "Metal") {
                id(filament_brand_code).publish_state("GFA02");
                id(filament_sub_brand).publish_state("PLA Metal");
              } else if (id(filament_variant).state == "Impact") {
                id(filament_brand_code).publish_state("GFA03");
                id(filament_sub_brand).publish_state("PLA Impact");
              } else { // Default to Basic if no variant specified
                id(filament_brand_code).publish_state("GFA00");
                id(filament_sub_brand).publish_state("PLA Basic");
              }
            } else { // Generic
              id(filament_brand_code).publish_state("GFL99");
              id(filament_sub_brand).publish_state("PLA");
            }
          }
          // PETG
          else if (id(filament_type).state == "PETG") {
            if (id(filament_brand).state == "Overture") {
              // TODO: find overture PETG brand code
              id(filament_brand_code).publish_state("GFG99"); // Using generic for now
              id(filament_sub_brand).publish_state("PETG");
            } else { // Generic
              id(filament_brand_code).publish_state("GFG99");
              id(filament_sub_brand).publish_state("PETG");
            }
          }
          // PET-CF
          else if (id(filament_type).state == "PET-CF") {
            if (id(filament_brand).state == "Bambu") {
              id(filament_brand_code).publish_state("GFT00");
              id(filament_sub_brand).publish_state("PET-CF");
            } else { // Generic - Note: Using PETG generic as there's no specific PET-CF generic code
              id(filament_brand_code).publish_state("GFG99");
              id(filament_sub_brand).publish_state("PET-CF");
            }
          }
          // ASA
          else if (id(filament_type).state == "ASA") {
            // Generic
            id(filament_brand_code).publish_state("GFB98");
            id(filament_sub_brand).publish_state("ASA");
          }
          // ABS
          else if (id(filament_type).state == "ABS") {
            if (id(filament_brand).state == "Bambu") {
              id(filament_brand_code).publish_state("GFB00");
              id(filament_sub_brand).publish_state("ABS");
            } else { // Generic
              id(filament_brand_code).publish_state("GFB99");
              id(filament_sub_brand).publish_state("ABS");
            }
          }
          // PC
          else if (id(filament_type).state == "PC") {
            if (id(filament_brand).state == "Bambu") {
              id(filament_brand_code).publish_state("GFC00");
              id(filament_sub_brand).publish_state("PC");
            } else { // Generic
              id(filament_brand_code).publish_state("GFC99");
              id(filament_sub_brand).publish_state("PC");
            }
          }
          // PA
          else if (id(filament_type).state == "PA") {
            // Generic
            id(filament_brand_code).publish_state("GFN99");
            id(filament_sub_brand).publish_state("PA");
          }
          // PA-CF
          else if (id(filament_type).state == "PA-CF") {
            if (id(filament_brand).state == "Bambu") {
              id(filament_brand_code).publish_state("GFN03");
              id(filament_sub_brand).publish_state("PA-CF");
            } else { // Generic
              id(filament_brand_code).publish_state("GFN98");
              id(filament_sub_brand).publish_state("PA-CF");
            }
          }
          // PLA-CF
          else if (id(filament_type).state == "PLA-CF") {
            // Generic
            id(filament_brand_code).publish_state("GFL98");
            id(filament_sub_brand).publish_state("PLA-CF");
          }
          // PVA
          else if (id(filament_type).state == "PVA") {
            // Generic
            id(filament_brand_code).publish_state("GFS99");
            id(filament_sub_brand).publish_state("PVA");
          }
          // Support Materials
          else if (id(filament_type).state == "Support") {
            if (id(filament_variant).state == "G") {
              id(filament_brand_code).publish_state("GFS01");
              id(filament_sub_brand).publish_state("Support G");
            } else if (id(filament_variant).state == "W") {
              id(filament_brand_code).publish_state("GFS00");
              id(filament_sub_brand).publish_state("Support W");
            } else { // Default to Support W if no variant specified
              id(filament_brand_code).publish_state("GFS00");
              id(filament_sub_brand).publish_state("Support W");
            }
          }
          else {
            ESP_LOGE("main", "Unknown filament type: %s", id(filament_type).state.c_str());
          }
  - id: generate_filament_temperatures
    then:
      - if:
          condition:
            and:
              - lambda: |-
                  if (id(filament_type).state == "") {
                    ESP_LOGD("main", "skipping generate_filament_temperatures because filament_type is emptry");
                    return false;
                  } else {
                    return true;
                  }
          then:
            - lambda: |-
                //TODO: add filament_variant temperatures
                if (id(filament_type).state == "TPU") {
                  if (id(filament_brand).state == "Generic") {
                    id(filament_min_temp).publish_state(200);
                    id(filament_max_temp).publish_state(250);
                  } else {
                    ESP_LOGW("main", "Unknown temperatures for TPU: %s", id(filament_brand).state.c_str());
                    id(filament_min_temp).publish_state(200);
                    id(filament_max_temp).publish_state(250);
                  }
                }
                else if (id(filament_type).state == "PLA") {
                  if (id(filament_brand).state == "Generic") {
                    id(filament_min_temp).publish_state(190);
                    id(filament_max_temp).publish_state(240);
                  } else {
                    ESP_LOGW("main", "Unknown temperatures for PLA: %s", id(filament_brand).state.c_str());
                    id(filament_min_temp).publish_state(190);
                    id(filament_max_temp).publish_state(240);
                  }
                }
                else if (id(filament_type).state == "PETG") {
                  if (id(filament_brand).state == "Generic") {
                    id(filament_min_temp).publish_state(220);
                    id(filament_max_temp).publish_state(270);
                  } else {
                    ESP_LOGW("main", "Unknown temperatures for PETG: %s", id(filament_brand).state.c_str());
                    id(filament_min_temp).publish_state(220);
                    id(filament_max_temp).publish_state(270);
                  }
                }
                else if (id(filament_type).state == "ASA") {
                  if (id(filament_brand).state == "Generic") {
                    //TODO: find temps for ASA
                  } else {
                    ESP_LOGW("main", "Unknown temperatures for ASA: %s", id(filament_brand).state.c_str());
                  }
                }
                else if (id(filament_type).state == "ABS") {
                  if (id(filament_brand).state == "Generic") {
                    id(filament_min_temp).publish_state(240);
                    id(filament_max_temp).publish_state(280);
                  } else {
                    ESP_LOGW("main", "Unknown temperatures for ABS: %s", id(filament_brand).state.c_str());
                  }
                }
                else if (id(filament_type).state == "PVA") {
                  if (id(filament_brand).state == "Generic") {
                    id(filament_min_temp).publish_state(190);
                    id(filament_max_temp).publish_state(240);
                  } else {
                    ESP_LOGW("main", "Unknown temperatures for PVA: %s", id(filament_brand).state.c_str());
                    id(filament_min_temp).publish_state(190);
                    id(filament_max_temp).publish_state(240);
                  }
                }
                else if (id(filament_type).state == "PA-CF") {
                  if (id(filament_brand).state == "Generic") {
                    id(filament_min_temp).publish_state(190);
                    id(filament_max_temp).publish_state(240);
                  } else {
                    ESP_LOGW("main", "Unknown temperatures for PA-CF: %s", id(filament_brand).state.c_str());
                    id(filament_min_temp).publish_state(190);
                    id(filament_max_temp).publish_state(240);
                  }
                }
                else if (id(filament_type).state == "PC") {
                  if (id(filament_brand).state == "Generic") {
                    //TODO: find temps for PC
                  } else {
                    ESP_LOGW("main", "Unknown temperatures for PC: %s", id(filament_brand).state.c_str());
                  }
                }
                else if (id(filament_type).state == "PA") {
                  if (id(filament_brand).state == "Generic") {
                    id(filament_min_temp).publish_state(190);
                    id(filament_max_temp).publish_state(240);
                  } else {
                    ESP_LOGW("main", "Unknown temperatures for PA: %s", id(filament_brand).state.c_str());
                    id(filament_min_temp).publish_state(190);
                    id(filament_max_temp).publish_state(240);
                  }
                }
                else {
                  ESP_LOGW("main", "Unknown filament type: %s", id(filament_type).state.c_str());
                }

  # - id: publish_filament_settings_rfid
  #   parameters:
  #     x: string
  #     ams_id: uint8_t
  #     ams_tray: uint8_t
  #   then:
  #     - if:
  #         condition:
  #           and:
  #             - lambda: |-
  #                 if (id(bambu_serial_number).state == "") {
  #                   ESP_LOGE("main", "Bambu Serial Number cannot be empty");
  #                   return false;
  #                 } else {
  #                   return true;
  #                 }
  #             - lambda: |-
  #                 if (id(bambu_ip_address).state == "") {
  #                   ESP_LOGE("main", "Bambu IP Address cannot be empty");
  #                   return false;
  #                 } else {
  #                   return true;
  #                 }
  #             - lambda: |-
  #                 if (id(bambu_lan_access_code).state == "") {
  #                   ESP_LOGE("main", "Bambu LAN Access Code cannot be empty");
  #                   return false;
  #                 } else {
  #                   return true;
  #                 }
  #             #TODO: Verify mqtt is enabled
  #             # TODO: duplicate paring is taking excessive memroy
  #             # - lambda: |-
  #             #     bool has_openspool = false;
  #             #     esphome::json::parse_json(x, [&](JsonObject root) {
  #             #       if (root.containsKey("openspool")) {
  #             #         has_openspool = true;
  #             #       } else {
  #             #         ESP_LOGW("main", "skipping publish_filament_settings_rfid because nfc tag does not contain an openspool key");
  #             #       }
  #             #       return true;
  #             #     });
  #             #     return has_openspool;
  #         then:
  #           # - mqtt.publish:
  #           #     topic: !lambda 'return "device/" + id(bambu_serial_number).state + "/request";'
  #           #     payload: !lambda |-
  #           #       std::string result;
  #           #       bool parse_success = json::parse_json(x, [&](JsonObject root) {
  #           #         // Check if this is an openspool protocol JSON
  #           #         if (!root.containsKey("protocol") || strcmp(root["protocol"].as<const char*>(), "openspool") != 0) {
  #           #           ESP_LOGW("main", "skipping publish_filament_settings_rfid because data is not openspool protocol");
  #           #           return false;
  #           #         }

  #           #         // Build the new JSON structure
  #           #         result = json::build_json([&](JsonObject root) {
  #           #           auto print = root.createNestedObject("print");
  #           #           print["sequence_id"] = "0";
  #           #           print["command"] = "ams_filament_setting";
  #           #           print["ams_id"] = ams_id;
  #           #           print["tray_id"] = ams_tray;
                      
  #           #           // Copy values directly from root object
  #           #           if (root.containsKey("color_hex")) {
  #           #             print["tray_color"] = root["color_hex"].as<const char*>();
  #           #           }
  #           #           if (root.containsKey("min_temp")) {
  #           #             print["nozzle_temp_min"] = root["min_temp"].as<const char*>();
  #           #           }
  #           #           if (root.containsKey("max_temp")) {
  #           #             print["nozzle_temp_max"] = root["max_temp"].as<const char*>();
  #           #           }
  #           #           if (root.containsKey("type")) {
  #           #             print["tray_type"] = root["type"].as<const char*>();
  #           #           }
                      
  #           #           print["setting_id"] = "";
                      
  #           #           // Get bambu code if type and brand exist
  #           #           if (root.containsKey("type") && root.containsKey("brand")) {
  #           #             print["tray_info_idx"] = get_bambu_code(
  #           #               root["type"].as<std::string>(),
  #           #               root["brand"].as<std::string>()
  #           #             );
  #           #           }
  #           #         });
  #           #         return true;
  #           #       });

  #           #       if (!parse_success) {
  #           #         ESP_LOGE("main", "Failed to parse JSON");
  #           #         return "";
  #           #       }

  #           #       // Execute the script with all required parameters
  #           #       id(publish_filament_settings_rfid).execute(x, ams_id, ams_tray);
  #           #       return result;
esphome:
  includes:
    - bambu_filament_codes.h

binary_sensor:
  - id: rfid_reader_spi_0_tag_parsed
    platform: template
    internal: true
    state_topic:
  - id: rfid_reader_spi_0_tag_is_openspool
    platform: template
    internal: true
    state_topic:
  #TODO: ADd binary sensors for every other rfid reader
